'''быстрая сортировка

Одна из самых быстрых сортировок. Идея алгоритма заключается в том, что выбирается опорный элемент, относительно которого
 будет происходит сортировка. Равные и бОльшие элементы помещаются справа, меньшие – слева. Затем к полученным подмассивам
  рекурсивно применяются два первых пункта.
  
реализация с рекурсиями имеет ряд недостатков, таких как возможное переполнение стека из-за большого количества вложенной рекурсии и то, 
что опорным элементом всегда берётся средний. Для примера это, может, и нормально, но при решении, например, олимпиадных задач, хитрое жюри
 может специально подобрать такие тесты, чтобы на них это решение работало слишком долго и не проходило в лимит. В принципе, в качестве опорного
  элемента можно брать любой, но лучше, чтобы он был максимально приближен к медиане, поэтому можно выбрать его случайно или взять средний по
   значению из первого, среднего и последнего. Зависимость быстродействия от опорного элемента — один из недостатков алгоритма, ничего с этим
    не поделать, но сильная деградация производительности происходит редко, обычно если сортируется специально подобранный набор чисел. 
    Если всё-таки нужна сортировка, работающая гарантированно быстро, можно использовать, например, пирамидальную сортировку, всегда 
    работающую строго за O(n log n). Обычно Qsort всё же выигрывает в производительности перед другими сортировками, не требует много 
    дополнительной памяти и достаточно прост в реализации, поэтому пользуется заслуженной популярностью.
  
  '''



def QuickPas(s, aL, aR):
    l, r = aL, aR
    mid = (s[l]+s[(l+r)/2]+s[r])/3
    while lmid:r-=1
        if l<=r:
            if s[l]>s[r]:
                s[l], s[r] = s[r], s[l]
            l+=1
            r-=1
    if r > aL: QuickPas(s, aL, r)
    if l < aR: QuickPas(s, l, aR)